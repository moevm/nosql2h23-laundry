## Содержание
1. [Нереляционная модель.](#1)\
1.1. [Описание назначений типов данных.](#11)\
1.2. [Описание назначений сущностей.](#12)\
1.3. [Оценка удельного объема информации (максимум).](#13)\
1.4. [Избыточность модели.](#14)\
1.5. [Направление роста модели.](#15)\
1.6. [Запросы к модели.](#16)
2. [Реляционная модель.](#2-реляционная-модель-postgresql)\
2.1. [Описание назначений типов данных.](#21)\
2.2. [Описание назначений сущностей.](#22)\
2.3. [Оценка удельного объема информации (максимум).](#23)\
2.4. [Избыточность модели.](#24)\
2.5. [Направление роста модели.](#25)\
2.6. [Запросы к модели.](#26)
3. [Сравнение моделей.](#3)\
3.1. [Запросы к модели.](#31)\
3.2. [Запросы по отдельным юзкейсам.](#32)
4. [Выводы.](#4)

<h1 id="1">1. Нереляционная модель</h1>

<h2 id="11">Описание назначений типов данных</h2>

| Тип              | Размер, байт | Описание |
|------------------|-------------------|----------|
| `INTEGER`        | 8            | Целые числа |
| `FLOAT`          | 8            | Дробные чисел |
| `STRING`         | 2/символ     | Строки |
| `LOCAL TIME`     | 8            | Время без учета часового пояса |
| `LOCAL DATETIME` | 8            | Дата и время без учета часового пояса |
| `DATE`           | 4            | Дата без учета часового пояса |
| `{}`             | -            | Ассоциативный массив (хэш-таблица/словарь) |
| `[]`             | -            | Массив разнородных объектов |

<h2 id="12">Описание назначений сущностей</h2>

![UML диаграмма для Neo4j](./images/Neo4J%20UML.png)

1. **Client** - модель клиента. Хранит все личные данные Клиента. На неё есть связь из Order, что позволяет получать Заказы данного пользователя и логин/пароль.

2. **Employee** - общая обобщение для сущностей Admin, Director и SuperUser. Хранит в себе личные данные пользователя, логин/пароль. У всех них есть связь с Salary, чтобы можно было получать историю Зарплат.

3. **Admin** - модель данных Администратора, подвид Employee. Имеет связь с Shift для возможности получения данных о проработанных днях (Открытые смены).

4. **Director** - модель данных Директора филиала, подвид Employee. Как и Admin имеет связь с Shift для тех же целей. Также имеет связь с Branch и Warehouse для работы с ними.

5. **SuperUser** - модель данных Владельца бизнеса/Суперпользователя, подвид Employee. Связей ни с чем не имеет. Отделен исключительно для выделения роли.

6. **Order** - модель заказа. Хранит стоимость заказа и его статус. Имеет связи с клиентом для определения заказчика, с Branch для определения Филиала-исполнителя, с Service для определения списка требуемых услуг.

7. **Service** - модель услуги. Хранит все данные услуг.

8. **Branch** - модель филиала. Хранит данные филиала. Имеет связи с Order (описано выше), с Admin и Director (описано выше) и с Warehouse для четкого соотношения между филиалом и складом.

9. **Warehouse** - модель склада. Хранит все данные данного склада. Помимо вышеописанных связей с Director и Branch имеет связь с Product для определения списка.

10. **Product** - модель для расходников. Хранит все данные о них.

11. **Shift** - модель для хранения данных об открытых сменах (днях).

12. **Salary** - модель для хранения данных о выданных зарплатах.

<h2 id="13">Оценка удельного объема информации (максимум)</h2>

**Client**: 2064 байта на данные (при 255 символов на каждом текстовом поле).<br>
Итого: 2064 байта / клиент.

**Employee**: 2802 байта на данные (при 255 символов на каждом текстовом поле).<br>
Итого: 2802 байта / сотрудник.

**Admin**: 2802 байта от Employee + 34 байта на связь с Branch.<br>
Итого: 2836 байт / админ.

**Director**: 2802 байта от Employee + 68 байта на связь с Branch и Warehouse.<br>
Итого: 2880 байт / админ.

**Order**: 132 байта на данные (при 50 символов в текстовом поле) + 68 байт на связи с клиентом и филиалом + 210 байт на связи с Service и данными о количестве (при макс. заказе).<br>
Итого: 410 байт / заказ.

**Service**: фиксированный размер в 5 элементов размером максимум в 116 байт каждый (при 50 символов в текстовом поле).<br>
Итого: 580 байт всего.

**Branch**: 826 байт на данные + 34 байта на связь со Warehouse.<br>
Итого: 860 байт / филиал.

**Warehouse**: 826 байт на данные + 252 байта на связи с Product с данными о количестве (при макс. наполненности).<br>
Итого: 1078 байт / склад.

**Product**: фиксированный размер в 6 элементов размером максимум в 126 байт каждый.<br>
Итого: 696 байт всего.

**Shift**: 40 байт на данные + 34 байта на связь с Employee.<br>
Итого: 74 байт / запись.

**Salary**: 48 байт на данные + 34 байта на связь с Employee.<br>
Итого: 82 байт / запись.

<h2 id="14">Избыточность модели</h2>

Для оценки избыточности модели искались решения, продиктованные больше не моделью, а свойствами используемой базы данных.

- Из таких можно выделить только тройку связей между Директором, Складом и Филиалом. В идеале можно обойтись лишь двумя. Т.е. избыточность в 34 байта на 1 такую тройку. 
- Также можно сказать, что названия связей тоже не обязательны для данной модели.

Таким образом избыточность (отношение между фактическим объемом модели и “чистым" объемом данных) стремится к 1.

<h2 id="15">Направление роста модели</h2>

Если направлением считать сущности, из-за которой модель больше всего набирает в размере, то это все виды **Employee**, ведь они требуют почти 3 KB на сущность, и **Shift**, ведь, если посмотреть на полный месяц работы, на одного **Employee** будет приходиться ~1.5 KB данных.

<h2 id="16">Запросы к модели</h2>

### 1. Авторизация.

```sql
MATCH (user:User {login:"some login"}) 
RETURN user
LIMIT 1
```

- Тип запроса: получение данных.
- Количество запросов: **1**.

### 2. Создание заказа.

```sql
MATCH (user:User {login:$login}), (branch:Branch {address:$address})
CREATE (user)<-[:ORDERED_BY]-(order:Order {...data…})-[:EXECUTED_BY]->(branch)
RETURN order
MATCH (service:Service {type:"some type"})
CREATE ($order)-[:CONTAINS {Amount:$amount}]->(service)
```

- Тип запроса: создание данных.
- Количество запросов: **n+1**:
  - **1** на создание заказа и первых двух связей;
  - **n** на создание связей на все услуги.

### 3. Подтверждение заказа.

```sql
MATCH (order:Order {Id:$Id})
SET order.status = $newStatus
```

- Тип запроса: изменение данных.
- Количество запросов: **1**.

### 4. Завершение заказа.

```sql
MATCH (order:Order {Id:$Id})
SET order.status = $newStatus
```

- Тип запроса: изменение данных.
- Количество запросов: **1**.

### 5. Отмена заказа со стороны персонала.

```sql
MATCH (order:Order {Id:$Id})
SET order.status = $newStatus
```

- Тип запроса: изменение данных.
- Количество запросов: **1**.

### 6. Узнать индивидуальный график работы.

```sql
MATCH (employee:Employee {Id:$Id})
return employee
```

- Тип запроса: получение данных.
- Количество запросов: **1**.
  - В сущности Employee находятся требуемые данные.
  - График работы никогда не будет отдельно запрашиваться.

### 7. Добавление товара в склад.

```sql
MATCH (warehouse:Warehouse {Id:$Id})-[st:STORE]->(product:Product {id:$Id})
WITH CASE st
  WHEN IS NULL THEN 0
  ELSE 1
END AS status
WHERE status = 0
CREATE ($warehouse)-[st:STORE (amount: $addAmount)]->($product)
WHERE status = 1
SET $st.amount += $addAmount
```

- Тип запроса: добавление/изменение данных.
- Количество запросов: **n**.
  -  Необходимо перебрать все изменяемые товары.

### 8. Списание товара со склада.

```sql
MATCH (warehouse:Warehouse {Id:$Id})-[st:STORE]->(product:Product {id:$Id})
WITH CASE st.amount
  WHEN $removeAmount THEN 0
  ELSE 1
END AS status
WHERE status = 0
DELETE $st
WHERE status = 1
SET $st.amount -= $removeAmount
```

- Тип запроса: изменение данных.
- Количество запросов: **n**.
  -  Необходимо перебрать все изменяемые товары.

### 9. Просмотр прибыли филиала.

```sql
MATCH (branch:Branch {Id:$id})<-[:EXECUTED_BY]-(order:Order {status="Finished"})
WHERE date($start) <=order.EditDate <= date($finish)
RETURN order
```

- Тип запроса: получение данных.
- Количество запросов: **1**.

### 10. Расчет зарплат.

```sql
MATCH (employee: Employee {Id:$id})<-[op:OPENED_BY]-(shift:Shift)
WHERE date($start) <= shift.Date <= date($finish)
RETURN count(shift)
```

- Тип запроса: получение данных.
- Количество запросов: **1**.

### 11. Расчет нагрузки на филиалы.

```sql
MATCH (branch:Branch {Id:$id})<-[:EXECUTED_BY]-(order:Order)
WHERE date($start) <= order.CreationDate <= date($finish)
RETURN count(order)

MATCH (branch:Branch {Id:$id})<-[:EXECUTED_BY]-(order:Order {state = "Finished"})
WHERE date($start) <= order.CreationDate <= date($finish)
RETURN count(order)
```

- Тип запроса: получение данных.
- Количество запросов: **2**.

<h1 id="2">2. Реляционная модель (PostgreSQL)</h1>

<h2 id="21">Описание назначений типов данных</h2>

| Тип          | Размер, байт | Описание |
|--------------|--------------|----------|
| `int`        | 4            | Целые числа |
| `varchar(n)` | 1/символ     | Строки |
| `money`      | 8            | Денежные данные |
| `smallint`   | 2            | Малые числа |
| `timestamp`  | 8            | Дата и время без учета часового пояса |
| `time`       | 8            | Время без учета часового пояса |

<h2 id="22">Описание назначений сущностей</h2>

![UML диаграмма для Neo4j](./images/SQL%20UML.png)

1. **Clients** - таблица клиентов. Хранит все личные данные клиента.

2. **Orders** - таблица заказов. Хранит стоимость заказа и его статус. Хранит в себе id клиента, который создал заказ, и id филиала, который выполняет данный заказ. 

3. **Services** - таблица услуг. Хранит все данные предоставляемых услуг.

4. **ServicesToOrders** - таблица для соотношения МНОГИЕ-КО-МНОГИМ между заказом и услугами в нем.

5. **Schedules** - таблица расписаний. Хранит время начала и конца для определенного дня недели. Имеет двойной ключ: id и день недели. Так по одному id можно получить все расписание. 

6. **Branches** - таблица филиалов. Хранит данные филиала, id своего элемента расписания. 

7. **Warehouses** - таблица складов. Хранит все данные склада, id своего элемента расписания, а также id привязанного филиала.

8. **Products** - таблица расходников. Хранит все данные о них.

9. **WarehousesToProducts** - таблица для соотношения МНОГИЕ-КО-МНОГИМ между складом и расходниками в нем.

10. **Admins** - таблица Администраторов. Помимо данных о самом администраторе хранит id на элемент расписания и id ассоциированного с данным администратором филиала.

11. **AdminShifts** - таблица открытых смен Администраторов. Хранит в себе id администратора и дату открытия смены.

12. **AdmiSalaries** - таблица выданных зарплат Администраторов. Хранит в себе id администратора, дату выдачи зарплаты и выданную сумму.

13. **Directors** - таблица Директоров филиалов. Имеет id элемента смены и id ассоциированных с данным директором филиала и склада.

14. **DirectorShifts** - таблица открытых смен Директоров. Хранит в себе id директора и дату открытия смены.

15. **DirectorSalaries** - таблица выданных зарплат Директоров. Хранит в себе id директора, дату выдачи зарплаты и выданную сумму.

16. **SuperUsers** - таблица Владельцев бизнеса/Суперпользователей. Помимо данных о пользователе хранит id элемента расписания.

17. **SuperUserSalaries** - таблица выданных зарплат Суперпользователей. Хранит в себе id суперпользователя, дату выдачи зарплаты и выданную сумму.

<h2 id="23">Оценка удельного объема информации (максимум)</h2>

**Clients**: 1040 байт (при всех текстовых полях в 255 символов).

**Orders**: 86 байт (при длине статуса в 50 символов).

**Services**: 112 байт на 5 элементов. 560 байт всего.

**ServicesToOrders**: 12 байт на запись. Максимум 60 байт на заказ.

**Schedules**: 22 байта на одну запись (один день недели). При полной 6 недельной занятости  132 байта.

**Branches**: 279 байт (при длине адреса в 255 символов).

**Warehouses**: 283 байт (при длине адреса в 255 символов).

**Products**: 27 байта на 6 элементов. 162 байта всего.

**WarehousesToProducts**: 12 байт на запись. Максимум 72 байта на склад.

**Admins**: 1068 байт (при всех текстовых полях в 255 символов, кроме телефона, где до 20 символов).

**AdminShifts**: 16 байт на запись.

**AdmiSalaries**: 24 байта на запись.

**Director**: 1072 байта (при всех текстовых полях в 255 символов, кроме телефона, где до 20 символов).

**DirectorShifts**: 16 байт на запись.

**DirectorSalaries**: 24 байта на запись.

**SuperUsers**: 1064 байт на запись (при всех текстовых полях в 255 символов, кроме телефона, где до 20 символов).

**SuperUserSalaries**: 24 байта на запись.

<h2 id="24">Избыточность модели</h2>

Для оценки избыточности модели искались решения, продиктованные больше не моделью, а свойствами используемой базы данных.

- Все таблицы для связи многие-ко-многим: в идеальном случае такую связь можно было бы представить списком на одной из сторон, т.ч. тут избыточность приблизительно 2 (т.е. данных в реально в 2 раза больше, чем могло бы быть в идеале).
- Во-вторых, из-за того, что в реляционных бд наследование - это сложная тема, и она не везде применима в модели, пришлось разделить сотрудников на - 3 таблицы с похожими данными и связями. Избыточность здесь выражается в хранении открытых смен и зарплат для каждого типа пользователя и достигает 2 и 3 соответственно. 

Получаем общую избыточность >3 (точно сложно назвать) для всей реляционной модели. 

<h2 id="25">Направление роста модели</h2>

Если направлением считать сущности, из-за которой модель больше всего набирает в размере, то это все виды пользователей, т.к. каждый требует около 1 Кб на хранение, и данные о сменах, т.к. за месяц на сотрудника набирается около 0.5 Кб.

<h2 id="26">Запросы к модели</h2>

###  1. Авторизация.

```sql
SELECT login, password
FROM Clients
WHERE login = $login
SELECT login, password
FROM Admins
WHERE login = $login
SELECT login, password
FROM SuperUsers
WHERE login = $login
SELECT login, password
FROM Directors
WHERE login = $login
```

- Тип запроса: получение данных.
- Количество запросов: **4** (на каждый тип пользователей).

### 2. Создание заказа.

```sql
INSERT INTO Orders VALUES
($clientId, $branchId, $money, “Created", $creationDate, $creationDate)

INSERT INTO ServicesToOrders VALUES
($serviceId, $orderId, $amount)
```

- Тип запроса: создание данных.
- Количество запросов: **n+1**:
  - **1** запрос на создание заказа;
  - **n** на создание связей между заказом и услугами.

### 3. Подтверждение заказа.

```sql
UPDATE Orders
SET Status = “Approved"
Where OrderId = $id
```

- Тип запроса: изменение данных.
- Количество запросов: **1**.

### 4. Завершение заказа.

```sql
UPDATE Orders
SET Status = “Finished"
Where OrderId = $id
```

- Тип запроса: изменение данных.
- Количество запросов: **1**.

### 5. Отмена заказа со стороны персонала.

```sql
UPDATE Orders
SET Status = “Canceled"
Where OrderId = $id
```

- Тип запроса: изменение данных.
- Количество запросов: **1**.

### 6. Узнать индивидуальный график работы

```sql
SELECT login, password
FROM Clients
WHERE login = $login
SELECT login, password
FROM Admins
WHERE login = $login
SELECT login, password
FROM SuperUsers
WHERE login = $login
SELECT login, password
FROM Directors
WHERE login = $login
```

- Тип запроса: получение данных.
- Количество запросов: **1**.
  - 1 из 4 запросов выше.

### 7. Добавление товара в склад.

```sql
SELECT *
FROM WarehousesToProducts 
WHERE WarehouseId = $id1 AND ProductId = $id2

(1) UPDATE WarehousesToProducts 
SET Amount = Amount + $addAmount
WHERE WarehouseId = $id1 AND ProductId = $id2

(2) INSERT INTO WarehousesToProducts VALUES
($id1, $id2, $addAmount)
```

- Тип запроса: добавление/изменение данных.
- Количество запросов: **2n**.
  -  Необходимо перебрать все изменяемые товары.

### 8. Списание товара со склада.

```sql
SELECT *
FROM WarehousesToProducts 
WHERE WarehouseId = $id1 AND ProductId = $id2

(1) UPDATE WarehousesToProducts 
SET Amount = Amount - $addAmount

WHERE WarehouseId = $id1 AND ProductId = $id2
(2) DELETE FROM WarehousesToProducts
WHERE WarehouseId = $id1 ANDProductId = $id2
```

- Тип запроса: изменение данных.
- Количество запросов: **2n**.
  -  Необходимо перебрать все изменяемые товары.

### 9. Просмотр прибыли филиала.

```sql
SELECT *
FROM Orders
WHERE BranchId = $branchId AND Status = “Completed" AND EditDate >= $startDate AND EditDate <= $finishDate
```

- Тип запроса: получение данных.
- Количество запросов: **1**.

### 10. Расчет зарплат.

```sql
SELECT count(*)
FROM AdminsShifts
WHERE AdminId = $id AND Date >= $startDate AND Date <= $finishDate

SELECT count(*)
FROM DirectorShifts
WHERE DirectorId = $adminId AND Date >= $startDate AND Date <= $finishDate
```

- Тип запроса: получение данных.
- Количество запросов: **1**.
  - 1 из 2 запросов выше.

### 11. Расчет нагрузки на филиалы.

```sql
SELECT *
FROM Orders
WHERE BranchId = $branchId AND Status = “Completed" AND EditDate >= $startDate AND EditDate <= $finishDate

SELECT *
FROM Orders
WHERE BranchId = $branchId AND EditDate >= $startDate AND EditDate <= $finishDate
```

- Тип запроса: получение данных.
- Количество запросов: **2**.

<h1 id="3">3. Сравнение моделей</h1>

### Удельный объем информации

Если сравнивать Neo4J с PostgreSQL, то можно заметить, что все таблицы в последнем требуют гораздо меньше памяти, чем графовая БД. Для примера:
Client: Neo4J - 2064 байт; PostgreSQL - 1040 байт. Разница почти в 2 раза
Order: Neo4J - 410 байт; PostgreSQL - 146 байт. Разница почти в 3 раза

Т.е. даже с большой избыточностью модели, PostgreSQL требует меньше памяти, чем Neo4J.

### Запросы по отдельным юзкейсам

При сравнении реляционной БД и нереляционной по количествам запросов и их сложности обнаруживается, что большинство запросов требует одинаковое количество вызовов и никак не зависит от заполненности БД. 
Но при этом два запроса: внесение товаров в склад и их списание в нереляционной БД требуют в два раза меньше запросов. 

<h1 id="4">4. Выводы</h1>

SQL выгоднее использовать с точки зрения экономия памяти, но не с точки зрения скорости работы и простоты модели.

Neo4J (NoSQL) выгоднее по количеству запросов для действий, что может привести к более быстрой работе, а также по простоте поддержки модели, которая легко расширяется в ширину при необходимости. Но при этом данная БД проигрывает по размерам сущностей.

Подводя итоги, можно сказать, что Neo4J для данной задачи будет более удачным выбором.
